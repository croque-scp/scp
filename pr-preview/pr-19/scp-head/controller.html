<!DOCTYPE html>
<html>
  <head>
    <style>
      iframe,
      #resizer-container {
        display: block !important;
      }
    </style>
    <script src="https://interwiki.scpwiki.com/resizeIframe.js" defer></script>
    <script>
      window.isController = true;

      // TODO: Predict what the next resize request will be and prefetch it

      /**
       * @typedef {Object} assertionState
       * @property {string} assertionId
       * @property {boolean} assertionActive
       */

      /**
       * @typedef {Object} contradiction
       * @property {string} contradictionId
       * @property {string?} conditionId
       * @propery {string} triggerMode
       */

      /**
       * @typedef {Object} scoutReport
       * @property {string} scoutName
       * @property {IntersectionObserverEntry} intersection
       * @property {string[]} assertions
       * @property {contradiction[]} contradictions
       */

      /**
       * @typedef {Object} queuedContradiction
       * @property {string} contradictionId
       * @property {string} blockingAssertionId
       */

      const assertionStates = [
        {
          assertionId: "10",
          assertionActive: true,
        },
      ];
      let contradictionQueue = [];

      function triggerContradiction(contradictionId) {
        const contradiction = assertionStates.find(
          (assertion) => assertion.assertionId === contradictionId
        );
        if (contradiction) {
          contradiction.assertionActive = true;
        } else {
          assertionStates.push({
            assertionId: contradictionId,
            assertionActive: true,
          });
        }
      }

      function processQueuedContradictions() {
        console.debug("Assertion states", assertionStates);
        console.debug("Processing queued contradictions");
        contradictionQueue = contradictionQueue.filter((contradiction) => {
          // Future feature: do not process a contradiction if its assertion was last known to be intersecting
          triggerContradiction(contradiction);
          return false;
        });
        console.debug("Assertion states", assertionStates);
      }

      function addQueuedContradiction(contradiction) {
        console.debug(
          `Queueing contradiction ${contradiction.contradictionId}`
        );
        if (
          // Queue if there is no condition
          contradiction.conditionId == null ||
          // Queue if there is a condition that matches an active assertion
          assertionStates.some(
            (assertion) =>
              assertion.assertionActive &&
              assertion.assertionId === contradiction.conditionId
          )
        ) {
          contradictionQueue.push(contradiction.contradictionId);
        }
      }

      function updateAssertions(resize) {
        let message = "";
        // Sort assertions for consistent order to minimise unique resize requests
        assertionStates.sort((a, b) =>
          a.assertionId.localeCompare(b.assertionId)
        );

        for (const assertion of assertionStates) {
          if (assertion.assertionActive) {
            message += assertion.assertionId + "0";
          }
        }
        console.debug("Sending message", message);
        resize(message);
      }

      const scoutMessageQueue = [];
      function processScoutMessage(message, resize) {
        if (message.origin !== location.origin) return;
        if (!message.data.scoutName) return;

        console.debug(`Received report from scout ${message.data.scoutName}`);

        // Receive list of assertions
        const scoutAssertions = message.data.assertions;

        // Receive list of contradictions
        const scoutContradictions = message.data.contradictions;

        // Trigger behaviour based on the contradiction trigger mode
        for (const contradiction of scoutContradictions) {
          if (contradiction.triggerMode === "visible") {
            if (message.data.intersection.isIntersecting)
              addQueuedContradiction(contradiction);
          } else if ((contradiction.triggerMode = "invisible-top")) {
            if (
              !message.data.intersection.isIntersecting &&
              message.data.intersection.boundingClientRect.top < 0
            )
              addQueuedContradiction(contradiction);
          } else {
            throw new Error(
              `Unknown contradiction trigger mode: ${contradiction.triggerMode}`
            );
          }
        }

        processQueuedContradictions();

        // Communicate any assertion state changes to page
        updateAssertions(resize);

        // If the scout is no longer useful, tell it to destroy itself
        // Right now that means if all of its contradictions have been processed
        // Future feature: AND its tracked assertions are all active
        if (
          scoutContradictions.every((contradiction) => {
            return (
              // Contradiction has made its way into the queue
              contradictionQueue.includes(contradiction.contradictionId) ||
              // Contradiction has already been applied
              assertionStates.some(
                (assertion) =>
                  assertion.assertionActive &&
                  assertion.assertionId === contradiction.contradictionId
              )
            );
          })
        ) {
          message.source.postMessage({
            scoutName: message.data.scoutName,
            instruction: "destroy",
          });
        }
      }

      // Queue messages until load event
      function queueScoutMessage(message) {
        scoutMessageQueue.push(message);
      }
      addEventListener("message", queueScoutMessage);

      addEventListener("load", () => {
        const resize = window.resizeIframe.createResizeIframe(
          "https://scp-sandbox-3.wikidot.com",
          location.href.replace(/^.*\//, "/"),
          100
        );
        removeEventListener("message", queueScoutMessage);
        addEventListener("message", (message) => {
          processScoutMessage(message, resize);
        });
        while (scoutMessageQueue.length > 0) {
          processScoutMessage(scoutMessageQueue.shift(), resize);
        }
      });
    </script>
  </head>

  <body></body>
</html>
