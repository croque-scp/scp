<!DOCTYPE html>
<html>
  <head>
    <style>
      iframe,
      #resizer-container {
        display: block !important;
      }
    </style>
    <script src="https://interwiki.scpwiki.com/resizeIframe.js" defer></script>
    <script>
      "use strict";
      window.isController = true;
      window.debug =
        (new URLSearchParams(location.search).get("debug") || "") === "true";

      /**
       * @typedef {Object} scoutReport
       * @property {string} eventName
       * @property {string} scoutName
       * @property {boolean} isIntersecting
       * @property {string | null} direction
       * @property {string[]} assertions
       * @property {scoutContradiction[]} contradictions
       */

      /**
       * @typedef {Object} scoutContradiction
       * @property {number} id
       * @property {string?} channelName
       * @property {number?} conditionId
       * @property {string?} conditionChannelName
       * @property {string} triggerMode
       */

      /**
       * @typedef {Object} queuedContradiction
       * @property {string} contradictionId
       * @property {string} blockingAssertionId
       */

      const AssertionChannel = class {
        #activeAssertion;

        /**
         * @param {string} name
         * @param {number} minId
         * @param {number} maxId
         */
        constructor(name, minId, maxId) {
          /** @type {string} */
          this.name = name;
          /** @type {number} */
          this.minId = minId;
          /** @type {number} */
          this.maxId = maxId;

          /** @type {number} */
          this.#activeAssertion = this.minId;

          /** @type {Set.<number>} */
          this.knownUpcomingStages = new Set();
        }

        /** @param {number} value */
        set activeAssertion(value) {
          if (value < this.minId || value > this.maxId)
            throw new Error(
              `Assertion ID ${value} is out of range for channel ${this.name}`
            );
          this.#activeAssertion = value;
        }

        /** @returns {number} */
        get activeAssertion() {
          return this.#activeAssertion;
        }

        /** @returns {number | null} */
        get expectedNextAssertion() {
          const upcomingAssertions = [...this.knownUpcomingStages].filter(
            (n) => n > this.#activeAssertion
          );
          if (upcomingAssertions.length === 0) return null;
          return Math.min(...upcomingAssertions);
        }
      };

      /** @type {Object.<string, AssertionChannel>} */
      const assertionChannels = [
        new AssertionChannel("A", 1, 9),
        new AssertionChannel("B", 10, 50),
        new AssertionChannel("C", 1, 9),
      ].reduce((acc, channel) => ({ ...acc, [channel.name]: channel }), {});

      const defaultAssertionChannel = assertionChannels["B"];

      /** @type {Array.<Contradiction>} */
      let contradictionQueue = [];

      const Contradiction = class {
        /**
         * @param {number} id
         * @param {string} triggerMode
         * @param {string | null} channelName
         * @param {number | null} conditionId
         * @param {string | null} conditionChannelName
         */
        constructor(
          id,
          triggerMode,
          channelName,
          conditionId = null,
          conditionChannelName = null
        ) {
          /** @type {number} */
          this.id = id;
          /** @type {string} */
          this.triggerMode = triggerMode;

          /** @type {number | null} */
          this.conditionId = conditionId;
          /** @type {AssertionChannel | null} */
          this.conditionChannel =
            conditionChannelName != null
              ? assertionChannels[conditionChannelName]
              : defaultAssertionChannel;

          if (
            this.conditionId != null &&
            (this.conditionId > this.conditionChannel.maxId ||
              this.conditionId < this.conditionChannel.minId)
          )
            throw new Error(
              `Contradiction ID ${this.conditionId}` +
                `is out of range for channel ${this.conditionChannel.name}` +
                `(${this.conditionChannel.minId} - ${this.conditionChannel.maxId})`
            );

          /** @type {AssertionChannel} */
          this.channel =
            channelName != null
              ? assertionChannels[channelName]
              : this.conditionId != null
              ? this.conditionChannel
              : defaultAssertionChannel;

          if (this.id > this.channel.maxId || this.id < this.channel.minId)
            throw new Error(
              `Contradiction ID ${this.id}` +
                `is out of range for channel ${this.channel.name}` +
                `(${this.channel.minId} - ${this.channel.maxId})`
            );

          this.shortName =
            this.conditionChannel.name +
            this.conditionId +
            "?" +
            this.channel.name +
            this.id;
        }

        queue() {
          if (window.debug)
            console.debug(
              `Attempting to queue contradiction ${this.shortName}`,
              this
            );
          const conditionsMatch =
            this.conditionId == null ||
            this.conditionId <= this.conditionChannel.activeAssertion;
          if (conditionsMatch) {
            contradictionQueue.push(this);
            console.debug(`Queued contradiction ${this.shortName}`);
          } else if (window.debug) {
            console.debug(`Did not queue contradiction ${this.shortName}`);
          }
        }

        trigger() {
          // Increment the channel's active assertion - never decrement
          if (window.debug)
            console.debug(`Triggering contradiction ${this.shortName}`, this);
          if (this.channel.activeAssertion < this.id)
            this.channel.activeAssertion = this.id;
        }
      };

      function processQueuedContradictions() {
        if (window.debug)
          console.debug("Processing queued contradictions", [
            ...contradictionQueue,
          ]);
        contradictionQueue = contradictionQueue.filter((contradiction) => {
          // TODO Filter out a contradiction if its assertion was last known to be intersecting
          // (the queue will always be emptied every time currently)
          contradiction.trigger();
          // Remove from queue if triggered
          return false;
        });
        if (window.debug)
          console.debug("Processed queued contradictions", [
            ...contradictionQueue,
          ]);
      }

      function sendAssertionState(resize) {
        // Remove all preloaders
        document
          .querySelectorAll(".preload-iframe")
          .forEach((iframe) => iframe.remove());

        const assertionState = [
          assertionChannels["A"].activeAssertion,
          ".",
          assertionChannels["B"].activeAssertion,
          "0",
          assertionChannels["C"].activeAssertion,
        ].join("");
        console.debug("Updating assertion state to", assertionState);
        resize(assertionState);

        preloadNextAssertionState();
      }

      function preloadNextAssertionState() {
        // Work out each of the possible next assertion states, assuming that each channel is equally likely to advance to its next stage
        const possibleAssertionStates = [];
        for (const [channelName, channel] of Object.entries(
          assertionChannels
        )) {
          if (channel.expectedNextAssertion) {
            possibleAssertionStates.push(
              [
                assertionChannels["A"][
                  channelName === "A"
                    ? "activeAssertion"
                    : "expectedNextAssertion"
                ],
                ".",
                assertionChannels["B"][
                  channelName === "B"
                    ? "activeAssertion"
                    : "expectedNextAssertion"
                ],
                "0",
                assertionChannels["C"][
                  channelName === "C"
                    ? "activeAssertion"
                    : "expectedNextAssertion"
                ],
              ].join("")
            );
          }
        }
        for (const possibleAssertionState of possibleAssertionStates) {
          console.debug(`Preloading assertion state ${possibleAssertionState}`);
          const preloadIframe = document.createElement("iframe");
          // Iframe is fully sandboxed - allow-same-origin being implicitly false should prevent the controller being resized
          preloadIframe.sandbox = true;
          preloadIframe.classList.add("preload-iframe");
          document.body.appendChild(preloadIframe);
          preloadIframe.src =
            document.referrer +
            "/common--javascript/resize-iframe.html?" +
            "#" +
            possibleAssertionState +
            "/" +
            location.href.replace(/^.*\//, "/");
        }
      }

      /**
       * @param {MessageEvent<scoutReport>} message
       * @param {function} resize
       */
      function processScoutReport(message, resize) {
        if (message.origin !== location.origin) return;
        const scoutReport = message.data;
        if (!scoutReport.scoutName) return;

        switch (scoutReport.eventName) {
          case "ScoutRegistration":
            processScoutRegistrationEvent(scoutReport);
            break;
          case "ScoutIntersectionStateChange":
            processScoutIntersectionEvent(scoutReport, resize);
            break;
          default:
            throw new Error(`Unknown event: ${scoutReport.eventName}`);
        }
      }

      /**
       * @param {scoutReport} scoutReport
       */
      function processScoutRegistrationEvent(scoutReport) {
        // Store contradiction IDs in the corresponding channel to be used for preloading
        for (const c of scoutReport.contradictions) {
          assertionChannels[c.channelName].knownUpcomingStages.push(c.id);
        }
      }

      /**
       * @param {scoutReport} scoutReport
       * @param {function} resize
       */
      function processScoutIntersectionEvent(scoutReport, resize) {
        // Receive list of assertions
        const scoutAssertions = scoutReport.assertions;

        // Receive list of contradictions
        const scoutContradictions = scoutReport.contradictions.map(
          (c) =>
            new Contradiction(
              c.id,
              c.triggerMode,
              c.channelName,
              c.conditionId,
              c.conditionChannelName
            )
        );

        if (window.debug)
          console.debug(`Received report from scout ${scoutReport.scoutName}`, {
            scoutAssertions,
            scoutContradictions,
            scoutReport,
          });

        // Trigger behaviour based on the contradiction trigger mode
        for (const contradiction of scoutContradictions) {
          if (contradiction.triggerMode === "visible") {
            if (scoutReport.isIntersecting) {
              if (window.debug)
                console.debug(
                  `Scout ${scoutReport.scoutName} visible: yes - queuing`
                );
              contradiction.queue();
            } else {
              if (window.debug)
                console.debug(
                  `Scout ${scoutReport.scoutName} visible: no - not queuing`
                );
            }
          } else if ((contradiction.triggerMode = "invisible-top")) {
            if (!scoutReport.isIntersecting && scoutReport.direction === "up") {
              if (window.debug)
                console.debug(
                  `Scout ${scoutReport.scoutName} invisible-top: yes -  queuing`
                );
              contradiction.queue();
            } else {
              if (window.debug)
                console.debug(
                  `Scout ${scoutReport.scoutName} invisible-top: no - not queuing`
                );
            }
          } else {
            throw new Error(
              `Unknown contradiction trigger mode: ${contradiction.triggerMode}`
            );
          }
        }

        if (contradictionQueue.length > 0) {
          processQueuedContradictions();

          // Communicate any assertion state changes to page
          sendAssertionState(resize);
        } else {
          if (window.debug)
            console.debug("No queued contradictions to process");
        }

        // If the scout is no longer useful, tell it to destroy itself
        // Right now that means if all of its contradictions have been processed
        // Future feature: AND its tracked assertions are all active
        const allContradictionsProcessed = scoutContradictions.every(
          (contradiction) => {
            return (
              // Contradiction has made its way into the queue
              contradictionQueue.includes(contradiction) ||
              // Contradiction has already been applied
              contradiction.channel.activeAssertion >= contradiction.id
            );
          }
        );
        if (allContradictionsProcessed)
          message.source.postMessage({
            scoutName: scoutReport.scoutName,
            instruction: "destroy",
          });
      }

      // Queue messages until load event
      const scoutReportQueue = [];
      function queueScoutReport(message) {
        if (window.debug) console.debug("Received message before load event");
        scoutReportQueue.push(message);
      }
      addEventListener("message", queueScoutReport);

      addEventListener("load", () => {
        const resize = window.resizeIframe.createResizeIframe(
          document.referrer,
          location.href.replace(/^.*\//, "/"),
          100
        );
        // Switch event listener to process new reports immediately
        removeEventListener("message", queueScoutReport);
        addEventListener("message", (message) => {
          processScoutReport(message, resize);
        });
        // Process all queued scout reports
        while (scoutReportQueue.length > 0) {
          processScoutReport(scoutReportQueue.shift(), resize);
        }
      });
    </script>
  </head>

  <body></body>
</html>
