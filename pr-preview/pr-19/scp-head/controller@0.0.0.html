<!DOCTYPE html>
<html>
  <head>
    <style>
      iframe,
      #resizer-container {
        display: block !important;
      }
    </style>
    <script src="https://interwiki.scpwiki.com/resizeIframe.js" defer></script>
    <script>
      "use strict;";
      window.isController = true;

      // TODO: Predict what the next resize request will be and prefetch it

      /**
       * @typedef {Object} scoutContradiction
       * @property {number} id
       * @property {string?} channelName
       * @property {number?} conditionId
       * @property {string?} conditionChannelName
       * @property {string} triggerMode
       */

      /**
       * @typedef {Object} scoutReport
       * @property {string} scoutName
       * @property {IntersectionObserverEntry} intersection
       * @property {string[]} assertions
       * @property {scoutContradiction[]} contradictions
       */

      /**
       * @typedef {Object} queuedContradiction
       * @property {string} contradictionId
       * @property {string} blockingAssertionId
       */

      const AssertionChannel = class {
        #activeAssertion;

        /**
         * @param {string} name
         * @param {number} minId
         * @param {number} maxId
         */
        constructor(name, minId, maxId) {
          /** @type {string} */
          this.name = name;
          /** @type {number} */
          this.minId = minId;
          /** @type {number} */
          this.maxId = maxId;

          /** @type {number} */
          this.#activeAssertion = this.minId;
        }

        /** @param {number} value */
        set activeAssertion(value) {
          if (value < this.minId || value > this.maxId)
            throw new Error(
              `Assertion ID ${value} is out of range for channel ${this.name}`
            );
          this.#activeAssertion = value;
        }

        /** @returns {number} */
        get activeAssertion() {
          return this.#activeAssertion;
        }
      };

      /** @type {Object.<string, AssertionChannel>} */
      const assertionChannels = [
        new AssertionChannel("A", 1, 9),
        new AssertionChannel("B", 10, 50),
        new AssertionChannel("C", 1, 9),
      ].reduce((acc, channel) => ({ ...acc, [channel.name]: channel }), {});

      const defaultAssertionChannel = assertionChannels["B"];

      /** @type {Array.<Contradiction>} */
      let contradictionQueue = [];

      const Contradiction = class {
        /**
         * @param {number} id
         * @param {string} triggerMode
         * @param {string | null} channelName
         * @param {number | null} conditionId
         * @param {string | null} conditionChannelName
         */
        constructor(
          id,
          triggerMode,
          channelName,
          conditionId = null,
          conditionChannelName = null
        ) {
          /** @type {number} */
          this.id = id;
          /** @type {string} */
          this.triggerMode = triggerMode;

          /** @type {number | null} */
          this.conditionId = conditionId;
          /** @type {AssertionChannel | null} */
          this.conditionChannel =
            conditionChannelName != null
              ? assertionChannels[conditionChannelName]
              : defaultAssertionChannel;

          if (
            this.conditionId != null &&
            (this.conditionId > this.conditionChannel.maxId ||
              this.conditionId < this.conditionChannel.minId)
          )
            throw new Error(
              `Contradiction ID ${this.conditionId}` +
                `is out of range for channel ${this.conditionChannel.name}` +
                `(${this.conditionChannel.minId} - ${this.conditionChannel.maxId})`
            );

          /** @type {AssertionChannel} */
          this.channel =
            channelName != null
              ? assertionChannels[channelName]
              : this.conditionId != null
              ? this.conditionChannel
              : defaultAssertionChannel;

          if (this.id > this.channel.maxId || this.id < this.channel.minId)
            throw new Error(
              `Contradiction ID ${this.id}` +
                `is out of range for channel ${this.channel.name}` +
                `(${this.channel.minId} - ${this.channel.maxId})`
            );
        }

        queue() {
          const conditionsMatch =
            this.conditionId == null ||
            this.conditionId <= this.conditionChannel.activeAssertion;
          if (conditionsMatch) contradictionQueue.push(this);
        }

        trigger() {
          // Increment the channel's active assertion - never decrement
          if (this.channel.activeAssertion < this.id)
            this.channel.activeAssertion = this.id;
        }
      };

      function processQueuedContradictions() {
        console.debug(contradictionQueue);
        const queueLength = contradictionQueue.length;
        contradictionQueue = contradictionQueue.filter((contradiction) => {
          // TODO Filter out a contradiction if its assertion was last known to be intersecting
          // (the queue will always be emptied every time currently)
          contradiction.trigger();
          // Remove from queue if triggered
          return false;
        });
        console.debug(
          `Processed ${
            queueLength - contradictionQueue.length
          }/${queueLength} queued contradictions`,
          contradictionQueue
        );
      }

      function sendAssertionState(resize) {
        const message = [
          assertionChannels["A"].activeAssertion,
          ".",
          assertionChannels["B"].activeAssertion,
          "0",
          assertionChannels["C"].activeAssertion,
        ].join("");
        console.debug("Updating assertion state to", message);
        resize(message);
      }

      function processScoutReport(message, resize) {
        if (message.origin !== location.origin) return;
        if (!message.data.scoutName) return;

        /** @type {scoutReport} */
        const scoutReport = message.data;

        // Receive list of assertions
        const scoutAssertions = scoutReport.assertions;

        // Receive list of contradictions
        const scoutContradictions = scoutReport.contradictions.map(
          (c) =>
            new Contradiction(
              c.id,
              c.triggerMode,
              c.channelName,
              c.conditionId,
              c.conditionChannelName
            )
        );

        console.debug(`Received report from scout ${scoutReport.scoutName}`, {
          scoutAssertions,
          scoutContradictions,
        });

        // Trigger behaviour based on the contradiction trigger mode
        for (const contradiction of scoutContradictions) {
          if (contradiction.triggerMode === "visible") {
            if (scoutReport.intersection.isIntersecting) contradiction.queue();
          } else if ((contradiction.triggerMode = "invisible-top")) {
            if (
              !scoutReport.intersection.isIntersecting &&
              scoutReport.intersection.boundingClientRect.top < 0
            )
              contradiction.queue();
          } else {
            throw new Error(
              `Unknown contradiction trigger mode: ${contradiction.triggerMode}`
            );
          }
        }

        if (contradictionQueue.length > 0) {
          processQueuedContradictions();

          // Communicate any assertion state changes to page
          sendAssertionState(resize);
        }

        // If the scout is no longer useful, tell it to destroy itself
        // Right now that means if all of its contradictions have been processed
        // Future feature: AND its tracked assertions are all active
        const allContradictionsProcessed = scoutContradictions.every(
          (contradiction) => {
            return (
              // Contradiction has made its way into the queue
              contradictionQueue.includes(contradiction) ||
              // Contradiction has already been applied
              contradiction.channel.activeAssertion >= contradiction.id
            );
          }
        );
        if (allContradictionsProcessed)
          message.source.postMessage({
            scoutName: scoutReport.scoutName,
            instruction: "destroy",
          });
      }

      // Queue messages until load event
      const scoutReportQueue = [];
      function queueScoutReport(message) {
        scoutReportQueue.push(message);
      }
      addEventListener("message", queueScoutReport);

      addEventListener("load", () => {
        const resize = window.resizeIframe.createResizeIframe(
          "https://scp-sandbox-3.wikidot.com",
          location.href.replace(/^.*\//, "/"),
          100
        );
        // Switch event listener to process new reports immediately
        removeEventListener("message", queueScoutReport);
        addEventListener("message", (message) => {
          processScoutReport(message, resize);
        });
        // Process all queued scout reports
        while (scoutReportQueue.length > 0) {
          processScoutReport(scoutReportQueue.shift(), resize);
        }
      });
    </script>
  </head>

  <body></body>
</html>
