<!DOCTYPE html>
<html>
  <head>
    <script src="https://interwiki.scpwiki.com/resizeIframe.js"></script>
    <script>
      window.isController = true;

      // TODO: Predict what the next resize request will be and prefetch it

      const resize = window.resizeIframe.createResizeIframe(
        document.referrer,
        location.href.replace(/^.*\//, "/"),
        0
      );

      /**
       * @typedef {Object} assertionState
       * @property {string} assertionId
       * @property {boolean} assertionActive
       */

      /**
       * @typedef {Object} contradiction
       * @property {string} contradictionId
       * @property {string?} conditionId
       * @propery {string} triggerMode
       */

      /**
       * @typedef {Object} scoutReport
       * @property {string} scoutName
       * @property {IntersectionObserverEntry} intersection
       * @property {string[]} assertions
       * @property {contradiction[]} contradictions
       */

      /**
       * @typedef {Object} queuedContradiction
       * @property {string} contradictionId
       * @property {string} blockingAssertionId
       */

      const assertionStates = [
        {
          assertionId: "10",
          assertionActive: true,
        },
      ];
      let contradictionQueue = [];

      function triggerContradiction(contradictionId) {
        const contradiction = assertionStates.find(
          (assertion) => assertion.assertionId === contradictionId
        );
        if (contradiction) {
          contradiction.assertionActive = true;
        } else {
          assertionStates.push({
            assertionId: contradictionId,
            assertionActive: true,
          });
        }
      }

      function processQueuedContradictions() {
        contradictionQueue = contradictionQueue.filter((contradiction) => {
          // Future feature: do not process a contradiction if its assertion was last known to be intersecting
          triggerContradiction(contradiction);
          return false;
        });
      }

      function addQueuedContradiction(contradiction) {
        if (
          // Queue if there is no condition
          contradiction.conditionId == null ||
          // Queue if there is a condition that matches an active assertion
          assertionStates.some(
            (assertion) =>
              assertion.assertionActive &&
              assertion.assertionId === contradiction.conditionId
          )
        ) {
          contradictionQueue.push(contradiction.contradictionId);
        }
      }

      function updateAssertions() {
        let message = "";
        // Sort assertions for consistent order to minimise unique resize requests
        assertionStates.sort((a, b) =>
          a.assertionId.localeCompare(b.assertionId)
        );

        for (const assertion of assertionStates) {
          if (assertion.assertionActive) {
            message += assertion.assertionId + "0";
          }
        }
        resize(message);
      }

      addEventListener("message", (message) => {
        if (message.origin !== location.origin) return;
        if (!message.data.scoutName) return;

        // Receive list of assertions
        const scoutAssertions = message.data.assertions;

        // Receive list of contradictions
        const scoutContradictions = message.data.contradictions;

        // Trigger behaviour based on the contradiction trigger mode
        for (const contradiction of scoutContradictions) {
          if (contradiction.triggerMode === "visible") {
            if (message.data.intersection.isIntersecting)
              addQueuedContradiction(contradiction);
          } else if ((contradiction.triggerMode = "invisible-top")) {
            if (
              !message.data.intersection.isIntersecting &&
              message.data.intersection.boundingClientRect.top < 0
            )
              addQueuedContradiction(contradiction);
          } else {
            throw new Error(
              `Unknown contradiction trigger mode: ${contradiction.triggerMode}`
            );
          }
        }

        // Trigger behaviour based on whether the scout is intersecting
        if (message.data.intersection.isIntersecting) {
          // Future feature: mark last known intersection state of each assertion in order to delay contradictions

          // Add contradictions to the queue, if their conditions are met
          for (const contradiction of scoutContradictions) {
          }
        }

        processQueuedContradictions();

        // Communicate any assertion state changes to page
        updateAssertions();

        // If the scout is no longer useful, tell it to destroy itself
        // Right now that means if all of its contradictions have been processed
        // Future feature: AND its tracked assertions are all active
        if (
          scoutContradictions.every((contradiction) => {
            return (
              // Contradiction has made its way into the queue
              contradictionQueue.includes(contradiction.contradictionId) ||
              // Contradiction has already been applied
              assertionStates.some(
                (assertion) =>
                  assertion.assertionActive &&
                  assertion.assertionId === contradiction.contradictionId
              )
            );
          })
        ) {
          message.source.postMessage({
            scoutName: message.data.scoutName,
            instruction: "destroy",
          });
        }
      });
    </script>
  </head>

  <body></body>
</html>
