<!DOCTYPE html>
<html>
  <head>
    <style>
      iframe,
      #resizer-container {
        display: block !important;
      }
    </style>
    <script src="https://interwiki.scpwiki.com/resizeIframe.js" defer></script>
    <script>
      "use strict;";
      window.isController = true;

      // TODO: Predict what the next resize request will be and prefetch it

      /**
       * @typedef {Object} assertionState
       * @property {number} assertionId
       * @property {boolean} assertionActive
       */

      /**
       * @typedef {Object} scoutContradiction
       * @property {number} id
       * @property {string?} channel
       * @property {number?} conditionId
       * @property {string?} conditionChannel
       * @property {string} triggerMode
       */

      /**
       * @typedef {Object} scoutReport
       * @property {string} scoutName
       * @property {IntersectionObserverEntry} intersection
       * @property {string[]} assertions
       * @property {scoutContradiction[]} contradictions
       */

      /**
       * @typedef {Object} queuedContradiction
       * @property {string} contradictionId
       * @property {string} blockingAssertionId
       */

      class AssertionChannel {
        /**
         * @param {string} name
         * @param {number} minId
         * @param {number} maxId
         */
        constructor(name, minId, maxId) {
          /** @type {string} */
          this.name = name;
          /** @type {number} */
          this.minId = minId;
          /** @type {number} */
          this.maxId = maxId;

          /** @type {Array.<assertionState>} */
          this.assertionStates = [
            {
              assertionId: this.minId,
              assertionActive: true,
            },
          ];
        }

        /**
         * @returns {number}
         */
        getHighestActiveAssertion() {
          return this.assertionStates.reduce((highest, state) => {
            if (state.assertionActive && state.assertionId > highest)
              return state.assertionId;
            else return highest;
          }, 0);
        }
      }

      /** @type {Object.<string, AssertionChannel>} */
      const assertionChannels = [
        new AssertionChannel("A", 1, 9),
        new AssertionChannel("B", 10, 50),
        new AssertionChannel("C", 1, 9),
      ].reduce((acc, channel) => ({ ...acc, [channel.name]: channel }), {});

      const defaultAssertionChannel = "B";

      /** @type {Array.<Contradiction>} */
      let contradictionQueue = [];

      class Contradiction {
        /**
         * @param {number} id
         * @param {string} triggerMode
         * @param {string | null} channel
         * @param {number | null} conditionId
         * @param {string | null} conditionChannel
         */
        constructor(
          id,
          triggerMode,
          channel,
          conditionId = null,
          conditionChannel = null
        ) {
          if (channel == null) channel = defaultAssertionChannel;
          if (conditionChannel == null)
            conditionChannel = defaultAssertionChannel;

          /** @type {number} */
          this.id = id;
          /** @type {string} */
          this.triggerMode = triggerMode;
          /** @type {AssertionChannel} */
          this.channel = assertionChannels[channel];
          /** @type {number} */
          this.conditionId = conditionId;
          /** @type {string} */
          this.conditionChannel = conditionChannel;
        }

        queue() {
          if (
            // Queue if there is no condition
            this.conditionId == null ||
            // Queue if there is a condition that matches an active assertion in the matching channel
            this.channel.assertionStates.some(
              (assertion) =>
                assertion.assertionActive &&
                assertion.assertionId === this.conditionId
            )
          ) {
            contradictionQueue.push(this);
            console.debug(`Queued contradiction ${this.id}`);
          } else {
            console.debug(`Did not queue contradiction ${this.id}`);
          }
        }

        trigger() {
          // Find the assertion in the matching channel and set it to active
          const assertion = this.channel.assertionStates.find(
            (assertion) => assertion.assertionId === this.id
          );
          if (assertion) {
            assertion.assertionActive = true;
          } else {
            // Create it if undefined
            this.channel.assertionStates.push({
              assertionId: this.id,
              assertionActive: true,
            });
          }
        }
      }

      function processQueuedContradictions() {
        console.debug(
          `Processing ${contradictionQueue.length} queued contradictions`
        );
        console.debug("Assertions before processing", assertionChannels);
        contradictionQueue = contradictionQueue.filter((contradiction) => {
          // TODO Filter out a contradiction if its assertion was last known to be intersecting
          contradiction.trigger();
          return false;
        });
        console.debug("Assertions after processing", assertionChannels);
      }

      function updateAssertions(resize) {
        const message = [
          assertionChannels["A"].getHighestActiveAssertion(),
          ".",
          assertionChannels["B"].getHighestActiveAssertion(),
          "0",
          assertionChannels["C"].getHighestActiveAssertion(),
        ].join("");
        console.debug("Sending message", message);
        resize(message);
      }

      const scoutMessageQueue = [];
      function processScoutMessage(message, resize) {
        if (message.origin !== location.origin) return;
        if (!message.data.scoutName) return;

        /** @type {scoutReport} */
        const scoutReport = message.data;

        console.debug(`Received report from scout ${scoutReport.scoutName}`);

        // Receive list of assertions
        const scoutAssertions = scoutReport.assertions;

        // Receive list of contradictions
        const scoutContradictions = scoutReport.contradictions.map(
          (c) =>
            new Contradiction(
              c.id,
              c.triggerMode,
              c.channel,
              c.conditionId,
              c.conditionChannel
            )
        );
        console.log(scoutContradictions);

        // Trigger behaviour based on the contradiction trigger mode
        for (const contradiction of scoutContradictions) {
          if (contradiction.triggerMode === "visible") {
            if (scoutReport.intersection.isIntersecting) contradiction.queue();
          } else if ((contradiction.triggerMode = "invisible-top")) {
            if (
              !scoutReport.intersection.isIntersecting &&
              scoutReport.intersection.boundingClientRect.top < 0
            )
              contradiction.queue();
          } else {
            throw new Error(
              `Unknown contradiction trigger mode: ${contradiction.triggerMode}`
            );
          }
        }

        if (contradictionQueue.length > 0) {
          processQueuedContradictions();

          // Communicate any assertion state changes to page
          updateAssertions(resize);
        }

        // If the scout is no longer useful, tell it to destroy itself
        // Right now that means if all of its contradictions have been processed
        // Future feature: AND its tracked assertions are all active
        if (
          scoutContradictions.every((contradiction) => {
            return (
              // Contradiction has made its way into the queue
              contradictionQueue.includes(contradiction) ||
              // Contradiction has already been applied
              contradiction.channel.assertionStates.some(
                (assertion) =>
                  assertion.assertionActive &&
                  assertion.assertionId === contradiction.id
              )
            );
          })
        ) {
          message.source.postMessage({
            scoutName: scoutReport.scoutName,
            instruction: "destroy",
          });
        }
      }

      // Queue messages until load event
      function queueScoutMessage(message) {
        scoutMessageQueue.push(message);
      }
      addEventListener("message", queueScoutMessage);

      addEventListener("load", () => {
        const resize = window.resizeIframe.createResizeIframe(
          "https://scp-sandbox-3.wikidot.com",
          location.href.replace(/^.*\//, "/"),
          100
        );
        removeEventListener("message", queueScoutMessage);
        addEventListener("message", (message) => {
          processScoutMessage(message, resize);
        });
        while (scoutMessageQueue.length > 0) {
          processScoutMessage(scoutMessageQueue.shift(), resize);
        }
      });
    </script>
  </head>

  <body></body>
</html>
